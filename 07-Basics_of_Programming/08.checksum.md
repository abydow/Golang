## Checksums of versions refers to using a hash of some artifact (code, binary, image, config, etc.) as the “version identifier” or as a strict verifier tied to a version string. This is common in modern package managers, Docker images, and CI/CD pipelines to guarantee that a “version” points to one exact set of bits, not just a label like 1.0.0.

## What a checksum is

A checksum is a small fixed-size value computed from arbitrary data using an algorithm like MD5, SHA‑1, or SHA‑256. Even a 1‑bit change in the input produces a completely different checksum, making it useful as a “digital fingerprint” of the data.

## Why tie checksums to versions

Traditional semantic versions (like 1.2.3) describe *intended* compatibility but do not guarantee that the file you have is exactly what the publisher built for that version. By binding a checksum to a version, systems can detect corruption, tampering, or silent rebuilds, ensuring that “v1.2.3+checksumX” is bit‑for‑bit identical everywhere it is used.

## Examples in modern tooling

- Docker images often use the image content digest (a SHA‑256 hash) as the canonical identifier; tags like latest are just human‑friendly aliases for that digest.
- Package managers and installers (apt, yum, pip, npm, etc.) verify downloaded artifacts against published checksums to ensure integrity and authenticity before installing.
- Some tools encode a checksum alongside a version string (for example, adding a “+sha512…” suffix) to enforce an exact binary for a given declared tool version, improving reproducibility.

## In version control and CI/CD

In Git, the commit hash is itself a cryptographic checksum of the tree contents and metadata, so it acts as a precise “version ID” for that project state. CI/CD and DevSecOps workflows propagate and verify checksums for artifacts (containers, archives, dependencies) to detect supply‑chain attacks, stale caches, or corrupted downloads before deployment.

## How to “write on” checksums of versions (for notes)

If you are preparing notes or documentation, a clear structure could be:  
- Definition of checksum and common algorithms (MD5, SHA‑256, etc.)
- Difference between semantic version (1.2.3) and checksum‑based version (content hash, Git commit, Docker digest)
- Use cases: download integrity, package managers, Docker, Git, CI/CD, supply‑chain security.
- Pros (exact reproducibility, tamper detection) and cons (less human‑friendly, long identifiers, need for tooling support).
